{\rtf1\ansi\ansicpg1252\cocoartf1265\cocoasubrtf210
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww12020\viewh11440\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\b\fs24 \cf0 To Fix
\b0 \
\
\strike \strikec0 deep deletion	\'85clear() and pop_back(), call clear() in destructor\strike0\striked0 \
\
\strike \strikec0 non-const alt	ver	\'85for indexing functions (check cpp ref)\strike0\striked0 \
\strike \strikec0 const T&		\'85for const mem functions that return a ref or a ptr\strike0\striked0 \
\strike \strikec0 emplace_back()	\'85C++11 feature, implement (and emplace() as well)\strike0\striked0 \
move constructor	\'85C++11 feature, learn and implement\
move assignment	\'85C++11 feature, learn and implement\
\
opt memory alloc	\'85constructor starts w/o array alloc, alloc on insert()/push_back()/emplace_back()\
opt capacity grow	\'85first alloc should jump to a small # (i.e. 10), grow to 2*(size + n) for insert, check max_size\
growth factor		\'85make it a defined constant (i.e. insert will grow to growth_factor*(size + n) instead)\
move_only struct	\'85make MyVector work with the provided struct as \'92T\'92 (use move semantics)\
\
	struct move_only\
	\{\
		move_only() = delete;\
		move_only( const move_only& ) = delete;\
		move_only( move_only&& r ) : i( std::move(r.i) ) \{\}\
		move_only& operator==( const move_only& ) = delete;\
		move_only& operator=( move_only&& r ) \{ i = std::move(r.i); return *this; \}\
		//\
		int i;\
	\}\
\
	Note:	\'93= delete\'94 at the end of the function declaration means omit/ban that function\
\
overload variants	\'85implement some key overload variants (i.e. resize() with init value)\
}